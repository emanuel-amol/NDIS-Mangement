{"ast":null,"code":"import * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport { parse, parseAsync, safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\nexport const $ZodType = /*@__PURE__*/core.$constructor(\"$ZodType\", (inst, def) => {\n  var _a;\n  inst ?? (inst = {});\n  inst._zod.def = def; // set _def property\n  inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n  inst._zod.version = version;\n  const checks = [...(inst._zod.def.checks ?? [])];\n  // if inst is itself a checks.$ZodCheck, run it as a check\n  if (inst._zod.traits.has(\"$ZodCheck\")) {\n    checks.unshift(inst);\n  }\n  for (const ch of checks) {\n    for (const fn of ch._zod.onattach) {\n      fn(inst);\n    }\n  }\n  if (checks.length === 0) {\n    // deferred initializer\n    // inst._zod.parse is not yet defined\n    (_a = inst._zod).deferred ?? (_a.deferred = []);\n    inst._zod.deferred?.push(() => {\n      inst._zod.run = inst._zod.parse;\n    });\n  } else {\n    const runChecks = (payload, checks, ctx) => {\n      let isAborted = util.aborted(payload);\n      let asyncResult;\n      for (const ch of checks) {\n        if (ch._zod.def.when) {\n          const shouldRun = ch._zod.def.when(payload);\n          if (!shouldRun) continue;\n        } else if (isAborted) {\n          continue;\n        }\n        const currLen = payload.issues.length;\n        const _ = ch._zod.check(payload);\n        if (_ instanceof Promise && ctx?.async === false) {\n          throw new core.$ZodAsyncError();\n        }\n        if (asyncResult || _ instanceof Promise) {\n          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n            await _;\n            const nextLen = payload.issues.length;\n            if (nextLen === currLen) return;\n            if (!isAborted) isAborted = util.aborted(payload, currLen);\n          });\n        } else {\n          const nextLen = payload.issues.length;\n          if (nextLen === currLen) continue;\n          if (!isAborted) isAborted = util.aborted(payload, currLen);\n        }\n      }\n      if (asyncResult) {\n        return asyncResult.then(() => {\n          return payload;\n        });\n      }\n      return payload;\n    };\n    // const handleChecksResult = (\n    //   checkResult: ParsePayload,\n    //   originalResult: ParsePayload,\n    //   ctx: ParseContextInternal\n    // ): util.MaybeAsync<ParsePayload> => {\n    //   // if the checks mutated the value && there are no issues, re-parse the result\n    //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)\n    //     return inst._zod.parse(checkResult, ctx);\n    //   return originalResult;\n    // };\n    const handleCanaryResult = (canary, payload, ctx) => {\n      // abort if the canary is aborted\n      if (util.aborted(canary)) {\n        canary.aborted = true;\n        return canary;\n      }\n      // run checks first, then\n      const checkResult = runChecks(payload, checks, ctx);\n      if (checkResult instanceof Promise) {\n        if (ctx.async === false) throw new core.$ZodAsyncError();\n        return checkResult.then(checkResult => inst._zod.parse(checkResult, ctx));\n      }\n      return inst._zod.parse(checkResult, ctx);\n    };\n    inst._zod.run = (payload, ctx) => {\n      if (ctx.skipChecks) {\n        return inst._zod.parse(payload, ctx);\n      }\n      if (ctx.direction === \"backward\") {\n        // run canary\n        // initial pass (no checks)\n        const canary = inst._zod.parse({\n          value: payload.value,\n          issues: []\n        }, {\n          ...ctx,\n          skipChecks: true\n        });\n        if (canary instanceof Promise) {\n          return canary.then(canary => {\n            return handleCanaryResult(canary, payload, ctx);\n          });\n        }\n        return handleCanaryResult(canary, payload, ctx);\n      }\n      // forward\n      const result = inst._zod.parse(payload, ctx);\n      if (result instanceof Promise) {\n        if (ctx.async === false) throw new core.$ZodAsyncError();\n        return result.then(result => runChecks(result, checks, ctx));\n      }\n      return runChecks(result, checks, ctx);\n    };\n  }\n  inst[\"~standard\"] = {\n    validate: value => {\n      try {\n        const r = safeParse(inst, value);\n        return r.success ? {\n          value: r.data\n        } : {\n          issues: r.error?.issues\n        };\n      } catch (_) {\n        return safeParseAsync(inst, value).then(r => r.success ? {\n          value: r.data\n        } : {\n          issues: r.error?.issues\n        });\n      }\n    },\n    vendor: \"zod\",\n    version: 1\n  };\n});\nexport { clone } from \"./util.js\";\nexport const $ZodString = /*@__PURE__*/core.$constructor(\"$ZodString\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n  inst._zod.parse = (payload, _) => {\n    if (def.coerce) try {\n      payload.value = String(payload.value);\n    } catch (_) {}\n    if (typeof payload.value === \"string\") return payload;\n    payload.issues.push({\n      expected: \"string\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodStringFormat = /*@__PURE__*/core.$constructor(\"$ZodStringFormat\", (inst, def) => {\n  // check initialization must come first\n  checks.$ZodCheckStringFormat.init(inst, def);\n  $ZodString.init(inst, def);\n});\nexport const $ZodGUID = /*@__PURE__*/core.$constructor(\"$ZodGUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.guid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodUUID = /*@__PURE__*/core.$constructor(\"$ZodUUID\", (inst, def) => {\n  if (def.version) {\n    const versionMap = {\n      v1: 1,\n      v2: 2,\n      v3: 3,\n      v4: 4,\n      v5: 5,\n      v6: 6,\n      v7: 7,\n      v8: 8\n    };\n    const v = versionMap[def.version];\n    if (v === undefined) throw new Error(`Invalid UUID version: \"${def.version}\"`);\n    def.pattern ?? (def.pattern = regexes.uuid(v));\n  } else def.pattern ?? (def.pattern = regexes.uuid());\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodEmail = /*@__PURE__*/core.$constructor(\"$ZodEmail\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.email);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodURL = /*@__PURE__*/core.$constructor(\"$ZodURL\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    try {\n      // Trim whitespace from input\n      const trimmed = payload.value.trim();\n      // @ts-ignore\n      const url = new URL(trimmed);\n      if (def.hostname) {\n        def.hostname.lastIndex = 0;\n        if (!def.hostname.test(url.hostname)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid hostname\",\n            pattern: regexes.hostname.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      if (def.protocol) {\n        def.protocol.lastIndex = 0;\n        if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n          payload.issues.push({\n            code: \"invalid_format\",\n            format: \"url\",\n            note: \"Invalid protocol\",\n            pattern: def.protocol.source,\n            input: payload.value,\n            inst,\n            continue: !def.abort\n          });\n        }\n      }\n      // Set the output value based on normalize flag\n      if (def.normalize) {\n        // Use normalized URL\n        payload.value = url.href;\n      } else {\n        // Preserve the original input (trimmed)\n        payload.value = trimmed;\n      }\n      return;\n    } catch (_) {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"url\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nexport const $ZodEmoji = /*@__PURE__*/core.$constructor(\"$ZodEmoji\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.emoji());\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodNanoID = /*@__PURE__*/core.$constructor(\"$ZodNanoID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.nanoid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID = /*@__PURE__*/core.$constructor(\"$ZodCUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cuid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID2 = /*@__PURE__*/core.$constructor(\"$ZodCUID2\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cuid2);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodULID = /*@__PURE__*/core.$constructor(\"$ZodULID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ulid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodXID = /*@__PURE__*/core.$constructor(\"$ZodXID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.xid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodKSUID = /*@__PURE__*/core.$constructor(\"$ZodKSUID\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ksuid);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODateTime = /*@__PURE__*/core.$constructor(\"$ZodISODateTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.datetime(def));\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODate = /*@__PURE__*/core.$constructor(\"$ZodISODate\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.date);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISOTime = /*@__PURE__*/core.$constructor(\"$ZodISOTime\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.time(def));\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODuration = /*@__PURE__*/core.$constructor(\"$ZodISODuration\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.duration);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodIPv4 = /*@__PURE__*/core.$constructor(\"$ZodIPv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ipv4);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = `ipv4`;\n  });\n});\nexport const $ZodIPv6 = /*@__PURE__*/core.$constructor(\"$ZodIPv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.ipv6);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    const bag = inst._zod.bag;\n    bag.format = `ipv6`;\n  });\n  inst._zod.check = payload => {\n    try {\n      // @ts-ignore\n      new URL(`http://[${payload.value}]`);\n      // return;\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"ipv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\nexport const $ZodCIDRv4 = /*@__PURE__*/core.$constructor(\"$ZodCIDRv4\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cidrv4);\n  $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCIDRv6 = /*@__PURE__*/core.$constructor(\"$ZodCIDRv6\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    const [address, prefix] = payload.value.split(\"/\");\n    try {\n      if (!prefix) throw new Error();\n      const prefixNum = Number(prefix);\n      if (`${prefixNum}` !== prefix) throw new Error();\n      if (prefixNum < 0 || prefixNum > 128) throw new Error();\n      // @ts-ignore\n      new URL(`http://[${address}]`);\n    } catch {\n      payload.issues.push({\n        code: \"invalid_format\",\n        format: \"cidrv6\",\n        input: payload.value,\n        inst,\n        continue: !def.abort\n      });\n    }\n  };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data) {\n  if (data === \"\") return true;\n  if (data.length % 4 !== 0) return false;\n  try {\n    // @ts-ignore\n    atob(data);\n    return true;\n  } catch {\n    return false;\n  }\n}\nexport const $ZodBase64 = /*@__PURE__*/core.$constructor(\"$ZodBase64\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.base64);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    inst._zod.bag.contentEncoding = \"base64\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data) {\n  if (!regexes.base64url.test(data)) return false;\n  const base64 = data.replace(/[-_]/g, c => c === \"-\" ? \"+\" : \"/\");\n  const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n  return isValidBase64(padded);\n}\nexport const $ZodBase64URL = /*@__PURE__*/core.$constructor(\"$ZodBase64URL\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.base64url);\n  $ZodStringFormat.init(inst, def);\n  inst._zod.onattach.push(inst => {\n    inst._zod.bag.contentEncoding = \"base64url\";\n  });\n  inst._zod.check = payload => {\n    if (isValidBase64URL(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"base64url\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodE164 = /*@__PURE__*/core.$constructor(\"$ZodE164\", (inst, def) => {\n  def.pattern ?? (def.pattern = regexes.e164);\n  $ZodStringFormat.init(inst, def);\n});\n//////////////////////////////   ZodJWT   //////////////////////////////\nexport function isValidJWT(token, algorithm = null) {\n  try {\n    const tokensParts = token.split(\".\");\n    if (tokensParts.length !== 3) return false;\n    const [header] = tokensParts;\n    if (!header) return false;\n    // @ts-ignore\n    const parsedHeader = JSON.parse(atob(header));\n    if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\") return false;\n    if (!parsedHeader.alg) return false;\n    if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm)) return false;\n    return true;\n  } catch {\n    return false;\n  }\n}\nexport const $ZodJWT = /*@__PURE__*/core.$constructor(\"$ZodJWT\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (isValidJWT(payload.value, def.alg)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: \"jwt\",\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodCustomStringFormat = /*@__PURE__*/core.$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n  $ZodStringFormat.init(inst, def);\n  inst._zod.check = payload => {\n    if (def.fn(payload.value)) return;\n    payload.issues.push({\n      code: \"invalid_format\",\n      format: def.format,\n      input: payload.value,\n      inst,\n      continue: !def.abort\n    });\n  };\n});\nexport const $ZodNumber = /*@__PURE__*/core.$constructor(\"$ZodNumber\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Number(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n      return payload;\n    }\n    const received = typeof input === \"number\" ? Number.isNaN(input) ? \"NaN\" : !Number.isFinite(input) ? \"Infinity\" : undefined : undefined;\n    payload.issues.push({\n      expected: \"number\",\n      code: \"invalid_type\",\n      input,\n      inst,\n      ...(received ? {\n        received\n      } : {})\n    });\n    return payload;\n  };\n});\nexport const $ZodNumberFormat = /*@__PURE__*/core.$constructor(\"$ZodNumber\", (inst, def) => {\n  checks.$ZodCheckNumberFormat.init(inst, def);\n  $ZodNumber.init(inst, def); // no format checksp\n});\nexport const $ZodBoolean = /*@__PURE__*/core.$constructor(\"$ZodBoolean\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.boolean;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = Boolean(payload.value);\n    } catch (_) {}\n    const input = payload.value;\n    if (typeof input === \"boolean\") return payload;\n    payload.issues.push({\n      expected: \"boolean\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodBigInt = /*@__PURE__*/core.$constructor(\"$ZodBigInt\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.bigint;\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) try {\n      payload.value = BigInt(payload.value);\n    } catch (_) {}\n    if (typeof payload.value === \"bigint\") return payload;\n    payload.issues.push({\n      expected: \"bigint\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodBigIntFormat = /*@__PURE__*/core.$constructor(\"$ZodBigInt\", (inst, def) => {\n  checks.$ZodCheckBigIntFormat.init(inst, def);\n  $ZodBigInt.init(inst, def); // no format checks\n});\nexport const $ZodSymbol = /*@__PURE__*/core.$constructor(\"$ZodSymbol\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"symbol\") return payload;\n    payload.issues.push({\n      expected: \"symbol\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodUndefined = /*@__PURE__*/core.$constructor(\"$ZodUndefined\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.undefined;\n  inst._zod.values = new Set([undefined]);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"undefined\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodNull = /*@__PURE__*/core.$constructor(\"$ZodNull\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.pattern = regexes.null;\n  inst._zod.values = new Set([null]);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (input === null) return payload;\n    payload.issues.push({\n      expected: \"null\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodAny = /*@__PURE__*/core.$constructor(\"$ZodAny\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nexport const $ZodUnknown = /*@__PURE__*/core.$constructor(\"$ZodUnknown\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = payload => payload;\n});\nexport const $ZodNever = /*@__PURE__*/core.$constructor(\"$ZodNever\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    payload.issues.push({\n      expected: \"never\",\n      code: \"invalid_type\",\n      input: payload.value,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodVoid = /*@__PURE__*/core.$constructor(\"$ZodVoid\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (typeof input === \"undefined\") return payload;\n    payload.issues.push({\n      expected: \"void\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodDate = /*@__PURE__*/core.$constructor(\"$ZodDate\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (def.coerce) {\n      try {\n        payload.value = new Date(payload.value);\n      } catch (_err) {}\n    }\n    const input = payload.value;\n    const isDate = input instanceof Date;\n    const isValidDate = isDate && !Number.isNaN(input.getTime());\n    if (isValidDate) return payload;\n    payload.issues.push({\n      expected: \"date\",\n      code: \"invalid_type\",\n      input,\n      ...(isDate ? {\n        received: \"Invalid Date\"\n      } : {}),\n      inst\n    });\n    return payload;\n  };\n});\nfunction handleArrayResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nexport const $ZodArray = /*@__PURE__*/core.$constructor(\"$ZodArray\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        expected: \"array\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = Array(input.length);\n    const proms = [];\n    for (let i = 0; i < input.length; i++) {\n      const item = input[i];\n      const result = def.element._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleArrayResult(result, payload, i)));\n      } else {\n        handleArrayResult(result, payload, i);\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload; //handleArrayResultsAsync(parseResults, final);\n  };\n});\nfunction handlePropertyResult(result, final, key, input) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(key, result.issues));\n  }\n  if (result.value === undefined) {\n    if (key in input) {\n      final.value[key] = undefined;\n    }\n  } else {\n    final.value[key] = result.value;\n  }\n}\nfunction normalizeDef(def) {\n  const keys = Object.keys(def.shape);\n  for (const k of keys) {\n    if (!def.shape[k]._zod.traits.has(\"$ZodType\")) {\n      throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n    }\n  }\n  const okeys = util.optionalKeys(def.shape);\n  return {\n    ...def,\n    keys,\n    keySet: new Set(keys),\n    numKeys: keys.length,\n    optionalKeys: new Set(okeys)\n  };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n  const unrecognized = [];\n  // iterate over input keys\n  const keySet = def.keySet;\n  const _catchall = def.catchall._zod;\n  const t = _catchall.def.type;\n  for (const key of Object.keys(input)) {\n    if (keySet.has(key)) continue;\n    if (t === \"never\") {\n      unrecognized.push(key);\n      continue;\n    }\n    const r = _catchall.run({\n      value: input[key],\n      issues: []\n    }, ctx);\n    if (r instanceof Promise) {\n      proms.push(r.then(r => handlePropertyResult(r, payload, key, input)));\n    } else {\n      handlePropertyResult(r, payload, key, input);\n    }\n  }\n  if (unrecognized.length) {\n    payload.issues.push({\n      code: \"unrecognized_keys\",\n      keys: unrecognized,\n      input,\n      inst\n    });\n  }\n  if (!proms.length) return payload;\n  return Promise.all(proms).then(() => {\n    return payload;\n  });\n}\nexport const $ZodObject = /*@__PURE__*/core.$constructor(\"$ZodObject\", (inst, def) => {\n  // requires cast because technically $ZodObject doesn't extend\n  $ZodType.init(inst, def);\n  const _normalized = util.cached(() => normalizeDef(def));\n  util.defineLazy(inst._zod, \"propValues\", () => {\n    const shape = def.shape;\n    const propValues = {};\n    for (const key in shape) {\n      const field = shape[key]._zod;\n      if (field.values) {\n        propValues[key] ?? (propValues[key] = new Set());\n        for (const v of field.values) propValues[key].add(v);\n      }\n    }\n    return propValues;\n  });\n  const isObject = util.isObject;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    payload.value = {};\n    const proms = [];\n    const shape = value.shape;\n    for (const key of value.keys) {\n      const el = shape[key];\n      const r = el._zod.run({\n        value: input[key],\n        issues: []\n      }, ctx);\n      if (r instanceof Promise) {\n        proms.push(r.then(r => handlePropertyResult(r, payload, key, input)));\n      } else {\n        handlePropertyResult(r, payload, key, input);\n      }\n    }\n    if (!catchall) {\n      return proms.length ? Promise.all(proms).then(() => payload) : payload;\n    }\n    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n  };\n});\nexport const $ZodObjectJIT = /*@__PURE__*/core.$constructor(\"$ZodObjectJIT\", (inst, def) => {\n  // requires cast because technically $ZodObject doesn't extend\n  $ZodObject.init(inst, def);\n  const superParse = inst._zod.parse;\n  const _normalized = util.cached(() => normalizeDef(def));\n  const generateFastpass = shape => {\n    const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n    const normalized = _normalized.value;\n    const parseStr = key => {\n      const k = util.esc(key);\n      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n    };\n    doc.write(`const input = payload.value;`);\n    const ids = Object.create(null);\n    let counter = 0;\n    for (const key of normalized.keys) {\n      ids[key] = `key_${counter++}`;\n    }\n    // A: preserve key order {\n    doc.write(`const newResult = {}`);\n    for (const key of normalized.keys) {\n      const id = ids[key];\n      const k = util.esc(key);\n      doc.write(`const ${id} = ${parseStr(key)};`);\n      doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n      `);\n    }\n    doc.write(`payload.value = newResult;`);\n    doc.write(`return payload;`);\n    const fn = doc.compile();\n    return (payload, ctx) => fn(shape, payload, ctx);\n  };\n  let fastpass;\n  const isObject = util.isObject;\n  const jit = !core.globalConfig.jitless;\n  const allowsEval = util.allowsEval;\n  const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n  const catchall = def.catchall;\n  let value;\n  inst._zod.parse = (payload, ctx) => {\n    value ?? (value = _normalized.value);\n    const input = payload.value;\n    if (!isObject(input)) {\n      payload.issues.push({\n        expected: \"object\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n      // always synchronous\n      if (!fastpass) fastpass = generateFastpass(def.shape);\n      payload = fastpass(payload, ctx);\n      if (!catchall) return payload;\n      return handleCatchall([], input, payload, ctx, value, inst);\n    }\n    return superParse(payload, ctx);\n  };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n  for (const result of results) {\n    if (result.issues.length === 0) {\n      final.value = result.value;\n      return final;\n    }\n  }\n  const nonaborted = results.filter(r => !util.aborted(r));\n  if (nonaborted.length === 1) {\n    final.value = nonaborted[0].value;\n    return nonaborted[0];\n  }\n  final.issues.push({\n    code: \"invalid_union\",\n    input: final.value,\n    inst,\n    errors: results.map(result => result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())))\n  });\n  return final;\n}\nexport const $ZodUnion = /*@__PURE__*/core.$constructor(\"$ZodUnion\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"optin\", () => def.options.some(o => o._zod.optin === \"optional\") ? \"optional\" : undefined);\n  util.defineLazy(inst._zod, \"optout\", () => def.options.some(o => o._zod.optout === \"optional\") ? \"optional\" : undefined);\n  util.defineLazy(inst._zod, \"values\", () => {\n    if (def.options.every(o => o._zod.values)) {\n      return new Set(def.options.flatMap(option => Array.from(option._zod.values)));\n    }\n    return undefined;\n  });\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    if (def.options.every(o => o._zod.pattern)) {\n      const patterns = def.options.map(o => o._zod.pattern);\n      return new RegExp(`^(${patterns.map(p => util.cleanRegex(p.source)).join(\"|\")})$`);\n    }\n    return undefined;\n  });\n  const single = def.options.length === 1;\n  const first = def.options[0]._zod.run;\n  inst._zod.parse = (payload, ctx) => {\n    if (single) {\n      return first(payload, ctx);\n    }\n    let async = false;\n    const results = [];\n    for (const option of def.options) {\n      const result = option._zod.run({\n        value: payload.value,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        results.push(result);\n        async = true;\n      } else {\n        if (result.issues.length === 0) return result;\n        results.push(result);\n      }\n    }\n    if (!async) return handleUnionResults(results, payload, inst, ctx);\n    return Promise.all(results).then(results => {\n      return handleUnionResults(results, payload, inst, ctx);\n    });\n  };\n});\nexport const $ZodDiscriminatedUnion = /*@__PURE__*/\ncore.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n  $ZodUnion.init(inst, def);\n  const _super = inst._zod.parse;\n  util.defineLazy(inst._zod, \"propValues\", () => {\n    const propValues = {};\n    for (const option of def.options) {\n      const pv = option._zod.propValues;\n      if (!pv || Object.keys(pv).length === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n      for (const [k, v] of Object.entries(pv)) {\n        if (!propValues[k]) propValues[k] = new Set();\n        for (const val of v) {\n          propValues[k].add(val);\n        }\n      }\n    }\n    return propValues;\n  });\n  const disc = util.cached(() => {\n    const opts = def.options;\n    const map = new Map();\n    for (const o of opts) {\n      const values = o._zod.propValues?.[def.discriminator];\n      if (!values || values.size === 0) throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n      for (const v of values) {\n        if (map.has(v)) {\n          throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n        }\n        map.set(v, o);\n      }\n    }\n    return map;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!util.isObject(input)) {\n      payload.issues.push({\n        code: \"invalid_type\",\n        expected: \"object\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const opt = disc.value.get(input?.[def.discriminator]);\n    if (opt) {\n      return opt._zod.run(payload, ctx);\n    }\n    if (def.unionFallback) {\n      return _super(payload, ctx);\n    }\n    // no matching discriminator\n    payload.issues.push({\n      code: \"invalid_union\",\n      errors: [],\n      note: \"No matching discriminator\",\n      discriminator: def.discriminator,\n      input,\n      path: [def.discriminator],\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodIntersection = /*@__PURE__*/core.$constructor(\"$ZodIntersection\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    const left = def.left._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const right = def.right._zod.run({\n      value: input,\n      issues: []\n    }, ctx);\n    const async = left instanceof Promise || right instanceof Promise;\n    if (async) {\n      return Promise.all([left, right]).then(([left, right]) => {\n        return handleIntersectionResults(payload, left, right);\n      });\n    }\n    return handleIntersectionResults(payload, left, right);\n  };\n});\nfunction mergeValues(a, b) {\n  // const aType = parse.t(a);\n  // const bType = parse.t(b);\n  if (a === b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (a instanceof Date && b instanceof Date && +a === +b) {\n    return {\n      valid: true,\n      data: a\n    };\n  }\n  if (util.isPlainObject(a) && util.isPlainObject(b)) {\n    const bKeys = Object.keys(b);\n    const sharedKeys = Object.keys(a).filter(key => bKeys.indexOf(key) !== -1);\n    const newObj = {\n      ...a,\n      ...b\n    };\n    for (const key of sharedKeys) {\n      const sharedValue = mergeValues(a[key], b[key]);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newObj[key] = sharedValue.data;\n    }\n    return {\n      valid: true,\n      data: newObj\n    };\n  }\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return {\n        valid: false,\n        mergeErrorPath: []\n      };\n    }\n    const newArray = [];\n    for (let index = 0; index < a.length; index++) {\n      const itemA = a[index];\n      const itemB = b[index];\n      const sharedValue = mergeValues(itemA, itemB);\n      if (!sharedValue.valid) {\n        return {\n          valid: false,\n          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n        };\n      }\n      newArray.push(sharedValue.data);\n    }\n    return {\n      valid: true,\n      data: newArray\n    };\n  }\n  return {\n    valid: false,\n    mergeErrorPath: []\n  };\n}\nfunction handleIntersectionResults(result, left, right) {\n  if (left.issues.length) {\n    result.issues.push(...left.issues);\n  }\n  if (right.issues.length) {\n    result.issues.push(...right.issues);\n  }\n  if (util.aborted(result)) return result;\n  const merged = mergeValues(left.value, right.value);\n  if (!merged.valid) {\n    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n  }\n  result.value = merged.data;\n  return result;\n}\nexport const $ZodTuple = /*@__PURE__*/core.$constructor(\"$ZodTuple\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const items = def.items;\n  const optStart = items.length - [...items].reverse().findIndex(item => item._zod.optin !== \"optional\");\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!Array.isArray(input)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"tuple\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    payload.value = [];\n    const proms = [];\n    if (!def.rest) {\n      const tooBig = input.length > items.length;\n      const tooSmall = input.length < optStart - 1;\n      if (tooBig || tooSmall) {\n        payload.issues.push({\n          ...(tooBig ? {\n            code: \"too_big\",\n            maximum: items.length\n          } : {\n            code: \"too_small\",\n            minimum: items.length\n          }),\n          input,\n          inst,\n          origin: \"array\"\n        });\n        return payload;\n      }\n    }\n    let i = -1;\n    for (const item of items) {\n      i++;\n      if (i >= input.length) if (i >= optStart) continue;\n      const result = item._zod.run({\n        value: input[i],\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleTupleResult(result, payload, i)));\n      } else {\n        handleTupleResult(result, payload, i);\n      }\n    }\n    if (def.rest) {\n      const rest = input.slice(items.length);\n      for (const el of rest) {\n        i++;\n        const result = def.rest._zod.run({\n          value: el,\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result => handleTupleResult(result, payload, i)));\n        } else {\n          handleTupleResult(result, payload, i);\n        }\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleTupleResult(result, final, index) {\n  if (result.issues.length) {\n    final.issues.push(...util.prefixIssues(index, result.issues));\n  }\n  final.value[index] = result.value;\n}\nexport const $ZodRecord = /*@__PURE__*/core.$constructor(\"$ZodRecord\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!util.isPlainObject(input)) {\n      payload.issues.push({\n        expected: \"record\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    if (def.keyType._zod.values) {\n      const values = def.keyType._zod.values;\n      payload.value = {};\n      for (const key of values) {\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n          const result = def.valueType._zod.run({\n            value: input[key],\n            issues: []\n          }, ctx);\n          if (result instanceof Promise) {\n            proms.push(result.then(result => {\n              if (result.issues.length) {\n                payload.issues.push(...util.prefixIssues(key, result.issues));\n              }\n              payload.value[key] = result.value;\n            }));\n          } else {\n            if (result.issues.length) {\n              payload.issues.push(...util.prefixIssues(key, result.issues));\n            }\n            payload.value[key] = result.value;\n          }\n        }\n      }\n      let unrecognized;\n      for (const key in input) {\n        if (!values.has(key)) {\n          unrecognized = unrecognized ?? [];\n          unrecognized.push(key);\n        }\n      }\n      if (unrecognized && unrecognized.length > 0) {\n        payload.issues.push({\n          code: \"unrecognized_keys\",\n          input,\n          inst,\n          keys: unrecognized\n        });\n      }\n    } else {\n      payload.value = {};\n      for (const key of Reflect.ownKeys(input)) {\n        if (key === \"__proto__\") continue;\n        const keyResult = def.keyType._zod.run({\n          value: key,\n          issues: []\n        }, ctx);\n        if (keyResult instanceof Promise) {\n          throw new Error(\"Async schemas not supported in object keys currently\");\n        }\n        if (keyResult.issues.length) {\n          payload.issues.push({\n            code: \"invalid_key\",\n            origin: \"record\",\n            issues: keyResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())),\n            input: key,\n            path: [key],\n            inst\n          });\n          payload.value[keyResult.value] = keyResult.value;\n          continue;\n        }\n        const result = def.valueType._zod.run({\n          value: input[key],\n          issues: []\n        }, ctx);\n        if (result instanceof Promise) {\n          proms.push(result.then(result => {\n            if (result.issues.length) {\n              payload.issues.push(...util.prefixIssues(key, result.issues));\n            }\n            payload.value[keyResult.value] = result.value;\n          }));\n        } else {\n          if (result.issues.length) {\n            payload.issues.push(...util.prefixIssues(key, result.issues));\n          }\n          payload.value[keyResult.value] = result.value;\n        }\n      }\n    }\n    if (proms.length) {\n      return Promise.all(proms).then(() => payload);\n    }\n    return payload;\n  };\n});\nexport const $ZodMap = /*@__PURE__*/core.$constructor(\"$ZodMap\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Map)) {\n      payload.issues.push({\n        expected: \"map\",\n        code: \"invalid_type\",\n        input,\n        inst\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Map();\n    for (const [key, value] of input) {\n      const keyResult = def.keyType._zod.run({\n        value: key,\n        issues: []\n      }, ctx);\n      const valueResult = def.valueType._zod.run({\n        value: value,\n        issues: []\n      }, ctx);\n      if (keyResult instanceof Promise || valueResult instanceof Promise) {\n        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n        }));\n      } else {\n        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n      }\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n  if (keyResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key, keyResult.issues));\n    } else {\n      final.issues.push({\n        code: \"invalid_key\",\n        origin: \"map\",\n        input,\n        inst,\n        issues: keyResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n      });\n    }\n  }\n  if (valueResult.issues.length) {\n    if (util.propertyKeyTypes.has(typeof key)) {\n      final.issues.push(...util.prefixIssues(key, valueResult.issues));\n    } else {\n      final.issues.push({\n        origin: \"map\",\n        code: \"invalid_element\",\n        input,\n        inst,\n        key: key,\n        issues: valueResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n      });\n    }\n  }\n  final.value.set(keyResult.value, valueResult.value);\n}\nexport const $ZodSet = /*@__PURE__*/core.$constructor(\"$ZodSet\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    const input = payload.value;\n    if (!(input instanceof Set)) {\n      payload.issues.push({\n        input,\n        inst,\n        expected: \"set\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    const proms = [];\n    payload.value = new Set();\n    for (const item of input) {\n      const result = def.valueType._zod.run({\n        value: item,\n        issues: []\n      }, ctx);\n      if (result instanceof Promise) {\n        proms.push(result.then(result => handleSetResult(result, payload)));\n      } else handleSetResult(result, payload);\n    }\n    if (proms.length) return Promise.all(proms).then(() => payload);\n    return payload;\n  };\n});\nfunction handleSetResult(result, final) {\n  if (result.issues.length) {\n    final.issues.push(...result.issues);\n  }\n  final.value.add(result.value);\n}\nexport const $ZodEnum = /*@__PURE__*/core.$constructor(\"$ZodEnum\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const values = util.getEnumValues(def.entries);\n  const valuesSet = new Set(values);\n  inst._zod.values = valuesSet;\n  inst._zod.pattern = new RegExp(`^(${values.filter(k => util.propertyKeyTypes.has(typeof k)).map(o => typeof o === \"string\" ? util.escapeRegex(o) : o.toString()).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (valuesSet.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodLiteral = /*@__PURE__*/core.$constructor(\"$ZodLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  if (def.values.length === 0) {\n    throw new Error(\"Cannot create literal schema with no valid values\");\n  }\n  inst._zod.values = new Set(def.values);\n  inst._zod.pattern = new RegExp(`^(${def.values.map(o => typeof o === \"string\" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)).join(\"|\")})$`);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    if (inst._zod.values.has(input)) {\n      return payload;\n    }\n    payload.issues.push({\n      code: \"invalid_value\",\n      values: def.values,\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodFile = /*@__PURE__*/core.$constructor(\"$ZodFile\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    const input = payload.value;\n    // @ts-ignore\n    if (input instanceof File) return payload;\n    payload.issues.push({\n      expected: \"file\",\n      code: \"invalid_type\",\n      input,\n      inst\n    });\n    return payload;\n  };\n});\nexport const $ZodTransform = /*@__PURE__*/core.$constructor(\"$ZodTransform\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      throw new core.$ZodEncodeError(inst.constructor.name);\n    }\n    const _out = def.transform(payload.value, payload);\n    if (ctx.async) {\n      const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n      return output.then(output => {\n        payload.value = output;\n        return payload;\n      });\n    }\n    if (_out instanceof Promise) {\n      throw new core.$ZodAsyncError();\n    }\n    payload.value = _out;\n    return payload;\n  };\n});\nfunction handleOptionalResult(result, input) {\n  if (result.issues.length && input === undefined) {\n    return {\n      issues: [],\n      value: undefined\n    };\n  }\n  return result;\n}\nexport const $ZodOptional = /*@__PURE__*/core.$constructor(\"$ZodOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  inst._zod.optout = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n  });\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    if (def.innerType._zod.optin === \"optional\") {\n      const result = def.innerType._zod.run(payload, ctx);\n      if (result instanceof Promise) return result.then(r => handleOptionalResult(r, payload.value));\n      return handleOptionalResult(result, payload.value);\n    }\n    if (payload.value === undefined) {\n      return payload;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodNullable = /*@__PURE__*/core.$constructor(\"$ZodNullable\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  util.defineLazy(inst._zod, \"pattern\", () => {\n    const pattern = def.innerType._zod.pattern;\n    return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n  });\n  util.defineLazy(inst._zod, \"values\", () => {\n    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    // Forward direction (decode): allow null to pass through\n    if (payload.value === null) return payload;\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodDefault = /*@__PURE__*/core.$constructor(\"$ZodDefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  // inst._zod.qin = \"true\";\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    // Forward direction (decode): apply defaults for undefined input\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n      /**\n       * $ZodDefault returns the default value immediately in forward direction.\n       * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n      return payload;\n    }\n    // Forward direction: continue with default handling\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => handleDefaultResult(result, def));\n    }\n    return handleDefaultResult(result, def);\n  };\n});\nfunction handleDefaultResult(payload, def) {\n  if (payload.value === undefined) {\n    payload.value = def.defaultValue;\n  }\n  return payload;\n}\nexport const $ZodPrefault = /*@__PURE__*/core.$constructor(\"$ZodPrefault\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.optin = \"optional\";\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    // Forward direction (decode): apply prefault for undefined input\n    if (payload.value === undefined) {\n      payload.value = def.defaultValue;\n    }\n    return def.innerType._zod.run(payload, ctx);\n  };\n});\nexport const $ZodNonOptional = /*@__PURE__*/core.$constructor(\"$ZodNonOptional\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => {\n    const v = def.innerType._zod.values;\n    return v ? new Set([...v].filter(x => x !== undefined)) : undefined;\n  });\n  inst._zod.parse = (payload, ctx) => {\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => handleNonOptionalResult(result, inst));\n    }\n    return handleNonOptionalResult(result, inst);\n  };\n});\nfunction handleNonOptionalResult(payload, inst) {\n  if (!payload.issues.length && payload.value === undefined) {\n    payload.issues.push({\n      code: \"invalid_type\",\n      expected: \"nonoptional\",\n      input: payload.value,\n      inst\n    });\n  }\n  return payload;\n}\nexport const $ZodSuccess = /*@__PURE__*/core.$constructor(\"$ZodSuccess\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      throw new core.$ZodEncodeError(\"ZodSuccess\");\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => {\n        payload.value = result.issues.length === 0;\n        return payload;\n      });\n    }\n    payload.value = result.issues.length === 0;\n    return payload;\n  };\n});\nexport const $ZodCatch = /*@__PURE__*/core.$constructor(\"$ZodCatch\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    // Forward direction (decode): apply catch logic\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(result => {\n        payload.value = result.value;\n        if (result.issues.length) {\n          payload.value = def.catchValue({\n            ...payload,\n            error: {\n              issues: result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n            },\n            input: payload.value\n          });\n          payload.issues = [];\n        }\n        return payload;\n      });\n    }\n    payload.value = result.value;\n    if (result.issues.length) {\n      payload.value = def.catchValue({\n        ...payload,\n        error: {\n          issues: result.issues.map(iss => util.finalizeIssue(iss, ctx, core.config()))\n        },\n        input: payload.value\n      });\n      payload.issues = [];\n    }\n    return payload;\n  };\n});\nexport const $ZodNaN = /*@__PURE__*/core.$constructor(\"$ZodNaN\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"nan\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nexport const $ZodPipe = /*@__PURE__*/core.$constructor(\"$ZodPipe\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      const right = def.out._zod.run(payload, ctx);\n      if (right instanceof Promise) {\n        return right.then(right => handlePipeResult(right, def.in, ctx));\n      }\n      return handlePipeResult(right, def.in, ctx);\n    }\n    const left = def.in._zod.run(payload, ctx);\n    if (left instanceof Promise) {\n      return left.then(left => handlePipeResult(left, def.out, ctx));\n    }\n    return handlePipeResult(left, def.out, ctx);\n  };\n});\nfunction handlePipeResult(left, next, ctx) {\n  if (left.issues.length) {\n    // prevent further checks\n    left.aborted = true;\n    return left;\n  }\n  return next._zod.run({\n    value: left.value,\n    issues: left.issues\n  }, ctx);\n}\nexport const $ZodCodec = /*@__PURE__*/core.$constructor(\"$ZodCodec\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n  util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n  inst._zod.parse = (payload, ctx) => {\n    const direction = ctx.direction || \"forward\";\n    if (direction === \"forward\") {\n      const left = def.in._zod.run(payload, ctx);\n      if (left instanceof Promise) {\n        return left.then(left => handleCodecAResult(left, def, ctx));\n      }\n      return handleCodecAResult(left, def, ctx);\n    } else {\n      const right = def.out._zod.run(payload, ctx);\n      if (right instanceof Promise) {\n        return right.then(right => handleCodecAResult(right, def, ctx));\n      }\n      return handleCodecAResult(right, def, ctx);\n    }\n  };\n});\nfunction handleCodecAResult(result, def, ctx) {\n  if (result.issues.length) {\n    // prevent further checks\n    result.aborted = true;\n    return result;\n  }\n  const direction = ctx.direction || \"forward\";\n  if (direction === \"forward\") {\n    const transformed = def.transform(result.value, result);\n    if (transformed instanceof Promise) {\n      return transformed.then(value => handleCodecTxResult(result, value, def.out, ctx));\n    }\n    return handleCodecTxResult(result, transformed, def.out, ctx);\n  } else {\n    const transformed = def.reverseTransform(result.value, result);\n    if (transformed instanceof Promise) {\n      return transformed.then(value => handleCodecTxResult(result, value, def.in, ctx));\n    }\n    return handleCodecTxResult(result, transformed, def.in, ctx);\n  }\n}\nfunction handleCodecTxResult(left, value, nextSchema, ctx) {\n  // Check if transform added any issues\n  if (left.issues.length) {\n    left.aborted = true;\n    return left;\n  }\n  return nextSchema._zod.run({\n    value,\n    issues: left.issues\n  }, ctx);\n}\nexport const $ZodReadonly = /*@__PURE__*/core.$constructor(\"$ZodReadonly\", (inst, def) => {\n  $ZodType.init(inst, def);\n  util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n  util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n  util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n  util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n  inst._zod.parse = (payload, ctx) => {\n    if (ctx.direction === \"backward\") {\n      return def.innerType._zod.run(payload, ctx);\n    }\n    const result = def.innerType._zod.run(payload, ctx);\n    if (result instanceof Promise) {\n      return result.then(handleReadonlyResult);\n    }\n    return handleReadonlyResult(result);\n  };\n});\nfunction handleReadonlyResult(payload) {\n  payload.value = Object.freeze(payload.value);\n  return payload;\n}\nexport const $ZodTemplateLiteral = /*@__PURE__*/core.$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n  $ZodType.init(inst, def);\n  const regexParts = [];\n  for (const part of def.parts) {\n    if (typeof part === \"object\" && part !== null) {\n      // is Zod schema\n      if (!part._zod.pattern) {\n        // if (!source)\n        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n      }\n      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n      if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n      const start = source.startsWith(\"^\") ? 1 : 0;\n      const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n      regexParts.push(source.slice(start, end));\n    } else if (part === null || util.primitiveTypes.has(typeof part)) {\n      regexParts.push(util.escapeRegex(`${part}`));\n    } else {\n      throw new Error(`Invalid template literal part: ${part}`);\n    }\n  }\n  inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"string\") {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        expected: \"template_literal\",\n        code: \"invalid_type\"\n      });\n      return payload;\n    }\n    inst._zod.pattern.lastIndex = 0;\n    if (!inst._zod.pattern.test(payload.value)) {\n      payload.issues.push({\n        input: payload.value,\n        inst,\n        code: \"invalid_format\",\n        format: def.format ?? \"template_literal\",\n        pattern: inst._zod.pattern.source\n      });\n      return payload;\n    }\n    return payload;\n  };\n});\nexport const $ZodFunction = /*@__PURE__*/core.$constructor(\"$ZodFunction\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._def = def;\n  inst._zod.def = def;\n  inst.implement = func => {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implement() must be called with a function\");\n    }\n    return function (...args) {\n      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;\n      const result = Reflect.apply(func, this, parsedArgs);\n      if (inst._def.output) {\n        return parse(inst._def.output, result);\n      }\n      return result;\n    };\n  };\n  inst.implementAsync = func => {\n    if (typeof func !== \"function\") {\n      throw new Error(\"implementAsync() must be called with a function\");\n    }\n    return async function (...args) {\n      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;\n      const result = await Reflect.apply(func, this, parsedArgs);\n      if (inst._def.output) {\n        return await parseAsync(inst._def.output, result);\n      }\n      return result;\n    };\n  };\n  inst._zod.parse = (payload, _ctx) => {\n    if (typeof payload.value !== \"function\") {\n      payload.issues.push({\n        code: \"invalid_type\",\n        expected: \"function\",\n        input: payload.value,\n        inst\n      });\n      return payload;\n    }\n    // Check if output is a promise type to determine if we should use async implementation\n    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === \"promise\";\n    if (hasPromiseOutput) {\n      payload.value = inst.implementAsync(payload.value);\n    } else {\n      payload.value = inst.implement(payload.value);\n    }\n    return payload;\n  };\n  inst.input = (...args) => {\n    const F = inst.constructor;\n    if (Array.isArray(args[0])) {\n      return new F({\n        type: \"function\",\n        input: new $ZodTuple({\n          type: \"tuple\",\n          items: args[0],\n          rest: args[1]\n        }),\n        output: inst._def.output\n      });\n    }\n    return new F({\n      type: \"function\",\n      input: args[0],\n      output: inst._def.output\n    });\n  };\n  inst.output = output => {\n    const F = inst.constructor;\n    return new F({\n      type: \"function\",\n      input: inst._def.input,\n      output\n    });\n  };\n  return inst;\n});\nexport const $ZodPromise = /*@__PURE__*/core.$constructor(\"$ZodPromise\", (inst, def) => {\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, ctx) => {\n    return Promise.resolve(payload.value).then(inner => def.innerType._zod.run({\n      value: inner,\n      issues: []\n    }, ctx));\n  };\n});\nexport const $ZodLazy = /*@__PURE__*/core.$constructor(\"$ZodLazy\", (inst, def) => {\n  $ZodType.init(inst, def);\n  // let _innerType!: any;\n  // util.defineLazy(def, \"getter\", () => {\n  //   if (!_innerType) {\n  //     _innerType = def.getter();\n  //   }\n  //   return () => _innerType;\n  // });\n  util.defineLazy(inst._zod, \"innerType\", () => def.getter());\n  util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType._zod.pattern);\n  util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType._zod.propValues);\n  util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType._zod.optin ?? undefined);\n  util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType._zod.optout ?? undefined);\n  inst._zod.parse = (payload, ctx) => {\n    const inner = inst._zod.innerType;\n    return inner._zod.run(payload, ctx);\n  };\n});\nexport const $ZodCustom = /*@__PURE__*/core.$constructor(\"$ZodCustom\", (inst, def) => {\n  checks.$ZodCheck.init(inst, def);\n  $ZodType.init(inst, def);\n  inst._zod.parse = (payload, _) => {\n    return payload;\n  };\n  inst._zod.check = payload => {\n    const input = payload.value;\n    const r = def.fn(input);\n    if (r instanceof Promise) {\n      return r.then(r => handleRefineResult(r, payload, input, inst));\n    }\n    handleRefineResult(r, payload, input, inst);\n    return;\n  };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n  if (!result) {\n    const _iss = {\n      code: \"custom\",\n      input,\n      inst,\n      // incorporates params.error into issue reporting\n      path: [...(inst._zod.def.path ?? [])],\n      // incorporates params.error into issue reporting\n      continue: !inst._zod.def.abort\n      // params: inst._zod.def.params,\n    };\n    if (inst._zod.def.params) _iss.params = inst._zod.def.params;\n    payload.issues.push(util.issue(_iss));\n  }\n}","map":{"version":3,"names":["checks","core","Doc","parse","parseAsync","safeParse","safeParseAsync","regexes","util","version","$ZodType","$constructor","inst","def","_a","_zod","bag","traits","has","unshift","ch","fn","onattach","length","deferred","push","run","runChecks","payload","ctx","isAborted","aborted","asyncResult","when","shouldRun","currLen","issues","_","check","Promise","async","$ZodAsyncError","resolve","then","nextLen","handleCanaryResult","canary","checkResult","skipChecks","direction","value","result","validate","r","success","data","error","vendor","clone","$ZodString","init","pattern","patterns","pop","string","coerce","String","expected","code","input","$ZodStringFormat","$ZodCheckStringFormat","$ZodGUID","guid","$ZodUUID","versionMap","v1","v2","v3","v4","v5","v6","v7","v8","v","undefined","Error","uuid","$ZodEmail","email","$ZodURL","trimmed","trim","url","URL","hostname","lastIndex","test","format","note","source","continue","abort","protocol","endsWith","slice","normalize","href","$ZodEmoji","emoji","$ZodNanoID","nanoid","$ZodCUID","cuid","$ZodCUID2","cuid2","$ZodULID","ulid","$ZodXID","xid","$ZodKSUID","ksuid","$ZodISODateTime","datetime","$ZodISODate","date","$ZodISOTime","time","$ZodISODuration","duration","$ZodIPv4","ipv4","$ZodIPv6","ipv6","$ZodCIDRv4","cidrv4","$ZodCIDRv6","cidrv6","address","prefix","split","prefixNum","Number","isValidBase64","atob","$ZodBase64","base64","contentEncoding","isValidBase64URL","base64url","replace","c","padded","padEnd","Math","ceil","$ZodBase64URL","$ZodE164","e164","isValidJWT","token","algorithm","tokensParts","header","parsedHeader","JSON","typ","alg","$ZodJWT","$ZodCustomStringFormat","$ZodNumber","number","_ctx","isNaN","isFinite","received","$ZodNumberFormat","$ZodCheckNumberFormat","$ZodBoolean","boolean","Boolean","$ZodBigInt","bigint","BigInt","$ZodBigIntFormat","$ZodCheckBigIntFormat","$ZodSymbol","$ZodUndefined","values","Set","optin","optout","$ZodNull","null","$ZodAny","$ZodUnknown","$ZodNever","$ZodVoid","$ZodDate","Date","_err","isDate","isValidDate","getTime","handleArrayResult","final","index","prefixIssues","$ZodArray","Array","isArray","proms","i","item","element","all","handlePropertyResult","key","normalizeDef","keys","Object","shape","k","okeys","optionalKeys","keySet","numKeys","handleCatchall","unrecognized","_catchall","catchall","t","type","$ZodObject","_normalized","cached","defineLazy","propValues","field","add","isObject","el","$ZodObjectJIT","superParse","generateFastpass","doc","normalized","parseStr","esc","write","ids","create","counter","id","compile","fastpass","jit","globalConfig","jitless","allowsEval","fastEnabled","handleUnionResults","results","nonaborted","filter","errors","map","iss","finalizeIssue","config","$ZodUnion","options","some","o","every","flatMap","option","from","RegExp","p","cleanRegex","join","single","first","$ZodDiscriminatedUnion","_super","pv","indexOf","entries","val","disc","opts","Map","discriminator","size","set","opt","get","unionFallback","path","$ZodIntersection","left","right","handleIntersectionResults","mergeValues","a","b","valid","isPlainObject","bKeys","sharedKeys","newObj","sharedValue","mergeErrorPath","newArray","itemA","itemB","merged","stringify","$ZodTuple","items","optStart","reverse","findIndex","rest","tooBig","tooSmall","maximum","minimum","origin","handleTupleResult","$ZodRecord","keyType","valueType","Reflect","ownKeys","keyResult","$ZodMap","valueResult","handleMapResult","propertyKeyTypes","$ZodSet","handleSetResult","$ZodEnum","getEnumValues","valuesSet","escapeRegex","toString","$ZodLiteral","$ZodFile","File","$ZodTransform","$ZodEncodeError","constructor","name","_out","transform","output","handleOptionalResult","$ZodOptional","innerType","$ZodNullable","$ZodDefault","defaultValue","handleDefaultResult","$ZodPrefault","$ZodNonOptional","x","handleNonOptionalResult","$ZodSuccess","$ZodCatch","catchValue","$ZodNaN","$ZodPipe","in","out","handlePipeResult","next","$ZodCodec","handleCodecAResult","transformed","handleCodecTxResult","reverseTransform","nextSchema","$ZodReadonly","handleReadonlyResult","freeze","$ZodTemplateLiteral","regexParts","part","parts","shift","start","startsWith","end","primitiveTypes","$ZodFunction","_def","implement","func","args","parsedArgs","apply","implementAsync","hasPromiseOutput","F","$ZodPromise","inner","$ZodLazy","getter","$ZodCustom","$ZodCheck","handleRefineResult","_iss","params","issue"],"sources":["C:/Users/singh/Downloads/NDIS_Project-9/frontend/node_modules/zod/v4/core/schemas.js"],"sourcesContent":["import * as checks from \"./checks.js\";\nimport * as core from \"./core.js\";\nimport { Doc } from \"./doc.js\";\nimport { parse, parseAsync, safeParse, safeParseAsync } from \"./parse.js\";\nimport * as regexes from \"./regexes.js\";\nimport * as util from \"./util.js\";\nimport { version } from \"./versions.js\";\nexport const $ZodType = /*@__PURE__*/ core.$constructor(\"$ZodType\", (inst, def) => {\n    var _a;\n    inst ?? (inst = {});\n    inst._zod.def = def; // set _def property\n    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object\n    inst._zod.version = version;\n    const checks = [...(inst._zod.def.checks ?? [])];\n    // if inst is itself a checks.$ZodCheck, run it as a check\n    if (inst._zod.traits.has(\"$ZodCheck\")) {\n        checks.unshift(inst);\n    }\n    for (const ch of checks) {\n        for (const fn of ch._zod.onattach) {\n            fn(inst);\n        }\n    }\n    if (checks.length === 0) {\n        // deferred initializer\n        // inst._zod.parse is not yet defined\n        (_a = inst._zod).deferred ?? (_a.deferred = []);\n        inst._zod.deferred?.push(() => {\n            inst._zod.run = inst._zod.parse;\n        });\n    }\n    else {\n        const runChecks = (payload, checks, ctx) => {\n            let isAborted = util.aborted(payload);\n            let asyncResult;\n            for (const ch of checks) {\n                if (ch._zod.def.when) {\n                    const shouldRun = ch._zod.def.when(payload);\n                    if (!shouldRun)\n                        continue;\n                }\n                else if (isAborted) {\n                    continue;\n                }\n                const currLen = payload.issues.length;\n                const _ = ch._zod.check(payload);\n                if (_ instanceof Promise && ctx?.async === false) {\n                    throw new core.$ZodAsyncError();\n                }\n                if (asyncResult || _ instanceof Promise) {\n                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n                        await _;\n                        const nextLen = payload.issues.length;\n                        if (nextLen === currLen)\n                            return;\n                        if (!isAborted)\n                            isAborted = util.aborted(payload, currLen);\n                    });\n                }\n                else {\n                    const nextLen = payload.issues.length;\n                    if (nextLen === currLen)\n                        continue;\n                    if (!isAborted)\n                        isAborted = util.aborted(payload, currLen);\n                }\n            }\n            if (asyncResult) {\n                return asyncResult.then(() => {\n                    return payload;\n                });\n            }\n            return payload;\n        };\n        // const handleChecksResult = (\n        //   checkResult: ParsePayload,\n        //   originalResult: ParsePayload,\n        //   ctx: ParseContextInternal\n        // ): util.MaybeAsync<ParsePayload> => {\n        //   // if the checks mutated the value && there are no issues, re-parse the result\n        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)\n        //     return inst._zod.parse(checkResult, ctx);\n        //   return originalResult;\n        // };\n        const handleCanaryResult = (canary, payload, ctx) => {\n            // abort if the canary is aborted\n            if (util.aborted(canary)) {\n                canary.aborted = true;\n                return canary;\n            }\n            // run checks first, then\n            const checkResult = runChecks(payload, checks, ctx);\n            if (checkResult instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));\n            }\n            return inst._zod.parse(checkResult, ctx);\n        };\n        inst._zod.run = (payload, ctx) => {\n            if (ctx.skipChecks) {\n                return inst._zod.parse(payload, ctx);\n            }\n            if (ctx.direction === \"backward\") {\n                // run canary\n                // initial pass (no checks)\n                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });\n                if (canary instanceof Promise) {\n                    return canary.then((canary) => {\n                        return handleCanaryResult(canary, payload, ctx);\n                    });\n                }\n                return handleCanaryResult(canary, payload, ctx);\n            }\n            // forward\n            const result = inst._zod.parse(payload, ctx);\n            if (result instanceof Promise) {\n                if (ctx.async === false)\n                    throw new core.$ZodAsyncError();\n                return result.then((result) => runChecks(result, checks, ctx));\n            }\n            return runChecks(result, checks, ctx);\n        };\n    }\n    inst[\"~standard\"] = {\n        validate: (value) => {\n            try {\n                const r = safeParse(inst, value);\n                return r.success ? { value: r.data } : { issues: r.error?.issues };\n            }\n            catch (_) {\n                return safeParseAsync(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));\n            }\n        },\n        vendor: \"zod\",\n        version: 1,\n    };\n});\nexport { clone } from \"./util.js\";\nexport const $ZodString = /*@__PURE__*/ core.$constructor(\"$ZodString\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? regexes.string(inst._zod.bag);\n    inst._zod.parse = (payload, _) => {\n        if (def.coerce)\n            try {\n                payload.value = String(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"string\")\n            return payload;\n        payload.issues.push({\n            expected: \"string\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodStringFormat\", (inst, def) => {\n    // check initialization must come first\n    checks.$ZodCheckStringFormat.init(inst, def);\n    $ZodString.init(inst, def);\n});\nexport const $ZodGUID = /*@__PURE__*/ core.$constructor(\"$ZodGUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.guid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodUUID = /*@__PURE__*/ core.$constructor(\"$ZodUUID\", (inst, def) => {\n    if (def.version) {\n        const versionMap = {\n            v1: 1,\n            v2: 2,\n            v3: 3,\n            v4: 4,\n            v5: 5,\n            v6: 6,\n            v7: 7,\n            v8: 8,\n        };\n        const v = versionMap[def.version];\n        if (v === undefined)\n            throw new Error(`Invalid UUID version: \"${def.version}\"`);\n        def.pattern ?? (def.pattern = regexes.uuid(v));\n    }\n    else\n        def.pattern ?? (def.pattern = regexes.uuid());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodEmail = /*@__PURE__*/ core.$constructor(\"$ZodEmail\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.email);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodURL = /*@__PURE__*/ core.$constructor(\"$ZodURL\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        try {\n            // Trim whitespace from input\n            const trimmed = payload.value.trim();\n            // @ts-ignore\n            const url = new URL(trimmed);\n            if (def.hostname) {\n                def.hostname.lastIndex = 0;\n                if (!def.hostname.test(url.hostname)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid hostname\",\n                        pattern: regexes.hostname.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            if (def.protocol) {\n                def.protocol.lastIndex = 0;\n                if (!def.protocol.test(url.protocol.endsWith(\":\") ? url.protocol.slice(0, -1) : url.protocol)) {\n                    payload.issues.push({\n                        code: \"invalid_format\",\n                        format: \"url\",\n                        note: \"Invalid protocol\",\n                        pattern: def.protocol.source,\n                        input: payload.value,\n                        inst,\n                        continue: !def.abort,\n                    });\n                }\n            }\n            // Set the output value based on normalize flag\n            if (def.normalize) {\n                // Use normalized URL\n                payload.value = url.href;\n            }\n            else {\n                // Preserve the original input (trimmed)\n                payload.value = trimmed;\n            }\n            return;\n        }\n        catch (_) {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"url\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodEmoji = /*@__PURE__*/ core.$constructor(\"$ZodEmoji\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.emoji());\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodNanoID = /*@__PURE__*/ core.$constructor(\"$ZodNanoID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.nanoid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID = /*@__PURE__*/ core.$constructor(\"$ZodCUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCUID2 = /*@__PURE__*/ core.$constructor(\"$ZodCUID2\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cuid2);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodULID = /*@__PURE__*/ core.$constructor(\"$ZodULID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ulid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodXID = /*@__PURE__*/ core.$constructor(\"$ZodXID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.xid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodKSUID = /*@__PURE__*/ core.$constructor(\"$ZodKSUID\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ksuid);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODateTime = /*@__PURE__*/ core.$constructor(\"$ZodISODateTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.datetime(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODate = /*@__PURE__*/ core.$constructor(\"$ZodISODate\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.date);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISOTime = /*@__PURE__*/ core.$constructor(\"$ZodISOTime\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.time(def));\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodISODuration = /*@__PURE__*/ core.$constructor(\"$ZodISODuration\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.duration);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodIPv4 = /*@__PURE__*/ core.$constructor(\"$ZodIPv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv4);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = `ipv4`;\n    });\n});\nexport const $ZodIPv6 = /*@__PURE__*/ core.$constructor(\"$ZodIPv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.ipv6);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        const bag = inst._zod.bag;\n        bag.format = `ipv6`;\n    });\n    inst._zod.check = (payload) => {\n        try {\n            // @ts-ignore\n            new URL(`http://[${payload.value}]`);\n            // return;\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"ipv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\nexport const $ZodCIDRv4 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv4\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv4);\n    $ZodStringFormat.init(inst, def);\n});\nexport const $ZodCIDRv6 = /*@__PURE__*/ core.$constructor(\"$ZodCIDRv6\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.cidrv6); // not used for validation\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        const [address, prefix] = payload.value.split(\"/\");\n        try {\n            if (!prefix)\n                throw new Error();\n            const prefixNum = Number(prefix);\n            if (`${prefixNum}` !== prefix)\n                throw new Error();\n            if (prefixNum < 0 || prefixNum > 128)\n                throw new Error();\n            // @ts-ignore\n            new URL(`http://[${address}]`);\n        }\n        catch {\n            payload.issues.push({\n                code: \"invalid_format\",\n                format: \"cidrv6\",\n                input: payload.value,\n                inst,\n                continue: !def.abort,\n            });\n        }\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64(data) {\n    if (data === \"\")\n        return true;\n    if (data.length % 4 !== 0)\n        return false;\n    try {\n        // @ts-ignore\n        atob(data);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodBase64 = /*@__PURE__*/ core.$constructor(\"$ZodBase64\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        inst._zod.bag.contentEncoding = \"base64\";\n    });\n    inst._zod.check = (payload) => {\n        if (isValidBase64(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\n//////////////////////////////   ZodBase64   //////////////////////////////\nexport function isValidBase64URL(data) {\n    if (!regexes.base64url.test(data))\n        return false;\n    const base64 = data.replace(/[-_]/g, (c) => (c === \"-\" ? \"+\" : \"/\"));\n    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, \"=\");\n    return isValidBase64(padded);\n}\nexport const $ZodBase64URL = /*@__PURE__*/ core.$constructor(\"$ZodBase64URL\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.base64url);\n    $ZodStringFormat.init(inst, def);\n    inst._zod.onattach.push((inst) => {\n        inst._zod.bag.contentEncoding = \"base64url\";\n    });\n    inst._zod.check = (payload) => {\n        if (isValidBase64URL(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"base64url\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodE164 = /*@__PURE__*/ core.$constructor(\"$ZodE164\", (inst, def) => {\n    def.pattern ?? (def.pattern = regexes.e164);\n    $ZodStringFormat.init(inst, def);\n});\n//////////////////////////////   ZodJWT   //////////////////////////////\nexport function isValidJWT(token, algorithm = null) {\n    try {\n        const tokensParts = token.split(\".\");\n        if (tokensParts.length !== 3)\n            return false;\n        const [header] = tokensParts;\n        if (!header)\n            return false;\n        // @ts-ignore\n        const parsedHeader = JSON.parse(atob(header));\n        if (\"typ\" in parsedHeader && parsedHeader?.typ !== \"JWT\")\n            return false;\n        if (!parsedHeader.alg)\n            return false;\n        if (algorithm && (!(\"alg\" in parsedHeader) || parsedHeader.alg !== algorithm))\n            return false;\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nexport const $ZodJWT = /*@__PURE__*/ core.$constructor(\"$ZodJWT\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (isValidJWT(payload.value, def.alg))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: \"jwt\",\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodCustomStringFormat = /*@__PURE__*/ core.$constructor(\"$ZodCustomStringFormat\", (inst, def) => {\n    $ZodStringFormat.init(inst, def);\n    inst._zod.check = (payload) => {\n        if (def.fn(payload.value))\n            return;\n        payload.issues.push({\n            code: \"invalid_format\",\n            format: def.format,\n            input: payload.value,\n            inst,\n            continue: !def.abort,\n        });\n    };\n});\nexport const $ZodNumber = /*@__PURE__*/ core.$constructor(\"$ZodNumber\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = inst._zod.bag.pattern ?? regexes.number;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Number(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"number\" && !Number.isNaN(input) && Number.isFinite(input)) {\n            return payload;\n        }\n        const received = typeof input === \"number\"\n            ? Number.isNaN(input)\n                ? \"NaN\"\n                : !Number.isFinite(input)\n                    ? \"Infinity\"\n                    : undefined\n            : undefined;\n        payload.issues.push({\n            expected: \"number\",\n            code: \"invalid_type\",\n            input,\n            inst,\n            ...(received ? { received } : {}),\n        });\n        return payload;\n    };\n});\nexport const $ZodNumberFormat = /*@__PURE__*/ core.$constructor(\"$ZodNumber\", (inst, def) => {\n    checks.$ZodCheckNumberFormat.init(inst, def);\n    $ZodNumber.init(inst, def); // no format checksp\n});\nexport const $ZodBoolean = /*@__PURE__*/ core.$constructor(\"$ZodBoolean\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.boolean;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = Boolean(payload.value);\n            }\n            catch (_) { }\n        const input = payload.value;\n        if (typeof input === \"boolean\")\n            return payload;\n        payload.issues.push({\n            expected: \"boolean\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigInt = /*@__PURE__*/ core.$constructor(\"$ZodBigInt\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.bigint;\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce)\n            try {\n                payload.value = BigInt(payload.value);\n            }\n            catch (_) { }\n        if (typeof payload.value === \"bigint\")\n            return payload;\n        payload.issues.push({\n            expected: \"bigint\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodBigIntFormat = /*@__PURE__*/ core.$constructor(\"$ZodBigInt\", (inst, def) => {\n    checks.$ZodCheckBigIntFormat.init(inst, def);\n    $ZodBigInt.init(inst, def); // no format checks\n});\nexport const $ZodSymbol = /*@__PURE__*/ core.$constructor(\"$ZodSymbol\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"symbol\")\n            return payload;\n        payload.issues.push({\n            expected: \"symbol\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodUndefined = /*@__PURE__*/ core.$constructor(\"$ZodUndefined\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.undefined;\n    inst._zod.values = new Set([undefined]);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"undefined\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodNull = /*@__PURE__*/ core.$constructor(\"$ZodNull\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.pattern = regexes.null;\n    inst._zod.values = new Set([null]);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (input === null)\n            return payload;\n        payload.issues.push({\n            expected: \"null\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodAny = /*@__PURE__*/ core.$constructor(\"$ZodAny\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodUnknown = /*@__PURE__*/ core.$constructor(\"$ZodUnknown\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload) => payload;\n});\nexport const $ZodNever = /*@__PURE__*/ core.$constructor(\"$ZodNever\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        payload.issues.push({\n            expected: \"never\",\n            code: \"invalid_type\",\n            input: payload.value,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodVoid = /*@__PURE__*/ core.$constructor(\"$ZodVoid\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (typeof input === \"undefined\")\n            return payload;\n        payload.issues.push({\n            expected: \"void\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodDate = /*@__PURE__*/ core.$constructor(\"$ZodDate\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (def.coerce) {\n            try {\n                payload.value = new Date(payload.value);\n            }\n            catch (_err) { }\n        }\n        const input = payload.value;\n        const isDate = input instanceof Date;\n        const isValidDate = isDate && !Number.isNaN(input.getTime());\n        if (isValidDate)\n            return payload;\n        payload.issues.push({\n            expected: \"date\",\n            code: \"invalid_type\",\n            input,\n            ...(isDate ? { received: \"Invalid Date\" } : {}),\n            inst,\n        });\n        return payload;\n    };\n});\nfunction handleArrayResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodArray = /*@__PURE__*/ core.$constructor(\"$ZodArray\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                expected: \"array\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = Array(input.length);\n        const proms = [];\n        for (let i = 0; i < input.length; i++) {\n            const item = input[i];\n            const result = def.element._zod.run({\n                value: item,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleArrayResult(result, payload, i)));\n            }\n            else {\n                handleArrayResult(result, payload, i);\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload; //handleArrayResultsAsync(parseResults, final);\n    };\n});\nfunction handlePropertyResult(result, final, key, input) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(key, result.issues));\n    }\n    if (result.value === undefined) {\n        if (key in input) {\n            final.value[key] = undefined;\n        }\n    }\n    else {\n        final.value[key] = result.value;\n    }\n}\nfunction normalizeDef(def) {\n    const keys = Object.keys(def.shape);\n    for (const k of keys) {\n        if (!def.shape[k]._zod.traits.has(\"$ZodType\")) {\n            throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n        }\n    }\n    const okeys = util.optionalKeys(def.shape);\n    return {\n        ...def,\n        keys,\n        keySet: new Set(keys),\n        numKeys: keys.length,\n        optionalKeys: new Set(okeys),\n    };\n}\nfunction handleCatchall(proms, input, payload, ctx, def, inst) {\n    const unrecognized = [];\n    // iterate over input keys\n    const keySet = def.keySet;\n    const _catchall = def.catchall._zod;\n    const t = _catchall.def.type;\n    for (const key of Object.keys(input)) {\n        if (keySet.has(key))\n            continue;\n        if (t === \"never\") {\n            unrecognized.push(key);\n            continue;\n        }\n        const r = _catchall.run({ value: input[key], issues: [] }, ctx);\n        if (r instanceof Promise) {\n            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));\n        }\n        else {\n            handlePropertyResult(r, payload, key, input);\n        }\n    }\n    if (unrecognized.length) {\n        payload.issues.push({\n            code: \"unrecognized_keys\",\n            keys: unrecognized,\n            input,\n            inst,\n        });\n    }\n    if (!proms.length)\n        return payload;\n    return Promise.all(proms).then(() => {\n        return payload;\n    });\n}\nexport const $ZodObject = /*@__PURE__*/ core.$constructor(\"$ZodObject\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodType.init(inst, def);\n    const _normalized = util.cached(() => normalizeDef(def));\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const shape = def.shape;\n        const propValues = {};\n        for (const key in shape) {\n            const field = shape[key]._zod;\n            if (field.values) {\n                propValues[key] ?? (propValues[key] = new Set());\n                for (const v of field.values)\n                    propValues[key].add(v);\n            }\n        }\n        return propValues;\n    });\n    const isObject = util.isObject;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        payload.value = {};\n        const proms = [];\n        const shape = value.shape;\n        for (const key of value.keys) {\n            const el = shape[key];\n            const r = el._zod.run({ value: input[key], issues: [] }, ctx);\n            if (r instanceof Promise) {\n                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));\n            }\n            else {\n                handlePropertyResult(r, payload, key, input);\n            }\n        }\n        if (!catchall) {\n            return proms.length ? Promise.all(proms).then(() => payload) : payload;\n        }\n        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);\n    };\n});\nexport const $ZodObjectJIT = /*@__PURE__*/ core.$constructor(\"$ZodObjectJIT\", (inst, def) => {\n    // requires cast because technically $ZodObject doesn't extend\n    $ZodObject.init(inst, def);\n    const superParse = inst._zod.parse;\n    const _normalized = util.cached(() => normalizeDef(def));\n    const generateFastpass = (shape) => {\n        const doc = new Doc([\"shape\", \"payload\", \"ctx\"]);\n        const normalized = _normalized.value;\n        const parseStr = (key) => {\n            const k = util.esc(key);\n            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n        };\n        doc.write(`const input = payload.value;`);\n        const ids = Object.create(null);\n        let counter = 0;\n        for (const key of normalized.keys) {\n            ids[key] = `key_${counter++}`;\n        }\n        // A: preserve key order {\n        doc.write(`const newResult = {}`);\n        for (const key of normalized.keys) {\n            const id = ids[key];\n            const k = util.esc(key);\n            doc.write(`const ${id} = ${parseStr(key)};`);\n            doc.write(`\n        if (${id}.issues.length) {\n          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${k}, ...iss.path] : [${k}]\n          })));\n        }\n        \n        if (${id}.value === undefined) {\n          if (${k} in input) {\n            newResult[${k}] = undefined;\n          }\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n      `);\n        }\n        doc.write(`payload.value = newResult;`);\n        doc.write(`return payload;`);\n        const fn = doc.compile();\n        return (payload, ctx) => fn(shape, payload, ctx);\n    };\n    let fastpass;\n    const isObject = util.isObject;\n    const jit = !core.globalConfig.jitless;\n    const allowsEval = util.allowsEval;\n    const fastEnabled = jit && allowsEval.value; // && !def.catchall;\n    const catchall = def.catchall;\n    let value;\n    inst._zod.parse = (payload, ctx) => {\n        value ?? (value = _normalized.value);\n        const input = payload.value;\n        if (!isObject(input)) {\n            payload.issues.push({\n                expected: \"object\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n            // always synchronous\n            if (!fastpass)\n                fastpass = generateFastpass(def.shape);\n            payload = fastpass(payload, ctx);\n            if (!catchall)\n                return payload;\n            return handleCatchall([], input, payload, ctx, value, inst);\n        }\n        return superParse(payload, ctx);\n    };\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n    for (const result of results) {\n        if (result.issues.length === 0) {\n            final.value = result.value;\n            return final;\n        }\n    }\n    const nonaborted = results.filter((r) => !util.aborted(r));\n    if (nonaborted.length === 1) {\n        final.value = nonaborted[0].value;\n        return nonaborted[0];\n    }\n    final.issues.push({\n        code: \"invalid_union\",\n        input: final.value,\n        inst,\n        errors: results.map((result) => result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config()))),\n    });\n    return final;\n}\nexport const $ZodUnion = /*@__PURE__*/ core.$constructor(\"$ZodUnion\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : undefined);\n    util.defineLazy(inst._zod, \"values\", () => {\n        if (def.options.every((o) => o._zod.values)) {\n            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n        }\n        return undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        if (def.options.every((o) => o._zod.pattern)) {\n            const patterns = def.options.map((o) => o._zod.pattern);\n            return new RegExp(`^(${patterns.map((p) => util.cleanRegex(p.source)).join(\"|\")})$`);\n        }\n        return undefined;\n    });\n    const single = def.options.length === 1;\n    const first = def.options[0]._zod.run;\n    inst._zod.parse = (payload, ctx) => {\n        if (single) {\n            return first(payload, ctx);\n        }\n        let async = false;\n        const results = [];\n        for (const option of def.options) {\n            const result = option._zod.run({\n                value: payload.value,\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                results.push(result);\n                async = true;\n            }\n            else {\n                if (result.issues.length === 0)\n                    return result;\n                results.push(result);\n            }\n        }\n        if (!async)\n            return handleUnionResults(results, payload, inst, ctx);\n        return Promise.all(results).then((results) => {\n            return handleUnionResults(results, payload, inst, ctx);\n        });\n    };\n});\nexport const $ZodDiscriminatedUnion = \n/*@__PURE__*/\ncore.$constructor(\"$ZodDiscriminatedUnion\", (inst, def) => {\n    $ZodUnion.init(inst, def);\n    const _super = inst._zod.parse;\n    util.defineLazy(inst._zod, \"propValues\", () => {\n        const propValues = {};\n        for (const option of def.options) {\n            const pv = option._zod.propValues;\n            if (!pv || Object.keys(pv).length === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(option)}\"`);\n            for (const [k, v] of Object.entries(pv)) {\n                if (!propValues[k])\n                    propValues[k] = new Set();\n                for (const val of v) {\n                    propValues[k].add(val);\n                }\n            }\n        }\n        return propValues;\n    });\n    const disc = util.cached(() => {\n        const opts = def.options;\n        const map = new Map();\n        for (const o of opts) {\n            const values = o._zod.propValues?.[def.discriminator];\n            if (!values || values.size === 0)\n                throw new Error(`Invalid discriminated union option at index \"${def.options.indexOf(o)}\"`);\n            for (const v of values) {\n                if (map.has(v)) {\n                    throw new Error(`Duplicate discriminator value \"${String(v)}\"`);\n                }\n                map.set(v, o);\n            }\n        }\n        return map;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isObject(input)) {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"object\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const opt = disc.value.get(input?.[def.discriminator]);\n        if (opt) {\n            return opt._zod.run(payload, ctx);\n        }\n        if (def.unionFallback) {\n            return _super(payload, ctx);\n        }\n        // no matching discriminator\n        payload.issues.push({\n            code: \"invalid_union\",\n            errors: [],\n            note: \"No matching discriminator\",\n            discriminator: def.discriminator,\n            input,\n            path: [def.discriminator],\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodIntersection = /*@__PURE__*/ core.$constructor(\"$ZodIntersection\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        const left = def.left._zod.run({ value: input, issues: [] }, ctx);\n        const right = def.right._zod.run({ value: input, issues: [] }, ctx);\n        const async = left instanceof Promise || right instanceof Promise;\n        if (async) {\n            return Promise.all([left, right]).then(([left, right]) => {\n                return handleIntersectionResults(payload, left, right);\n            });\n        }\n        return handleIntersectionResults(payload, left, right);\n    };\n});\nfunction mergeValues(a, b) {\n    // const aType = parse.t(a);\n    // const bType = parse.t(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    if (a instanceof Date && b instanceof Date && +a === +b) {\n        return { valid: true, data: a };\n    }\n    if (util.isPlainObject(a) && util.isPlainObject(b)) {\n        const bKeys = Object.keys(b);\n        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return { valid: false, mergeErrorPath: [] };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false,\n                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    return { valid: false, mergeErrorPath: [] };\n}\nfunction handleIntersectionResults(result, left, right) {\n    if (left.issues.length) {\n        result.issues.push(...left.issues);\n    }\n    if (right.issues.length) {\n        result.issues.push(...right.issues);\n    }\n    if (util.aborted(result))\n        return result;\n    const merged = mergeValues(left.value, right.value);\n    if (!merged.valid) {\n        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);\n    }\n    result.value = merged.data;\n    return result;\n}\nexport const $ZodTuple = /*@__PURE__*/ core.$constructor(\"$ZodTuple\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const items = def.items;\n    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== \"optional\");\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!Array.isArray(input)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"tuple\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        payload.value = [];\n        const proms = [];\n        if (!def.rest) {\n            const tooBig = input.length > items.length;\n            const tooSmall = input.length < optStart - 1;\n            if (tooBig || tooSmall) {\n                payload.issues.push({\n                    ...(tooBig ? { code: \"too_big\", maximum: items.length } : { code: \"too_small\", minimum: items.length }),\n                    input,\n                    inst,\n                    origin: \"array\",\n                });\n                return payload;\n            }\n        }\n        let i = -1;\n        for (const item of items) {\n            i++;\n            if (i >= input.length)\n                if (i >= optStart)\n                    continue;\n            const result = item._zod.run({\n                value: input[i],\n                issues: [],\n            }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n            }\n            else {\n                handleTupleResult(result, payload, i);\n            }\n        }\n        if (def.rest) {\n            const rest = input.slice(items.length);\n            for (const el of rest) {\n                i++;\n                const result = def.rest._zod.run({\n                    value: el,\n                    issues: [],\n                }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));\n                }\n                else {\n                    handleTupleResult(result, payload, i);\n                }\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleTupleResult(result, final, index) {\n    if (result.issues.length) {\n        final.issues.push(...util.prefixIssues(index, result.issues));\n    }\n    final.value[index] = result.value;\n}\nexport const $ZodRecord = /*@__PURE__*/ core.$constructor(\"$ZodRecord\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!util.isPlainObject(input)) {\n            payload.issues.push({\n                expected: \"record\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        if (def.keyType._zod.values) {\n            const values = def.keyType._zod.values;\n            payload.value = {};\n            for (const key of values) {\n                if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"symbol\") {\n                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                    if (result instanceof Promise) {\n                        proms.push(result.then((result) => {\n                            if (result.issues.length) {\n                                payload.issues.push(...util.prefixIssues(key, result.issues));\n                            }\n                            payload.value[key] = result.value;\n                        }));\n                    }\n                    else {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[key] = result.value;\n                    }\n                }\n            }\n            let unrecognized;\n            for (const key in input) {\n                if (!values.has(key)) {\n                    unrecognized = unrecognized ?? [];\n                    unrecognized.push(key);\n                }\n            }\n            if (unrecognized && unrecognized.length > 0) {\n                payload.issues.push({\n                    code: \"unrecognized_keys\",\n                    input,\n                    inst,\n                    keys: unrecognized,\n                });\n            }\n        }\n        else {\n            payload.value = {};\n            for (const key of Reflect.ownKeys(input)) {\n                if (key === \"__proto__\")\n                    continue;\n                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n                if (keyResult instanceof Promise) {\n                    throw new Error(\"Async schemas not supported in object keys currently\");\n                }\n                if (keyResult.issues.length) {\n                    payload.issues.push({\n                        code: \"invalid_key\",\n                        origin: \"record\",\n                        issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                        input: key,\n                        path: [key],\n                        inst,\n                    });\n                    payload.value[keyResult.value] = keyResult.value;\n                    continue;\n                }\n                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);\n                if (result instanceof Promise) {\n                    proms.push(result.then((result) => {\n                        if (result.issues.length) {\n                            payload.issues.push(...util.prefixIssues(key, result.issues));\n                        }\n                        payload.value[keyResult.value] = result.value;\n                    }));\n                }\n                else {\n                    if (result.issues.length) {\n                        payload.issues.push(...util.prefixIssues(key, result.issues));\n                    }\n                    payload.value[keyResult.value] = result.value;\n                }\n            }\n        }\n        if (proms.length) {\n            return Promise.all(proms).then(() => payload);\n        }\n        return payload;\n    };\n});\nexport const $ZodMap = /*@__PURE__*/ core.$constructor(\"$ZodMap\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Map)) {\n            payload.issues.push({\n                expected: \"map\",\n                code: \"invalid_type\",\n                input,\n                inst,\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Map();\n        for (const [key, value] of input) {\n            const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);\n            const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);\n            if (keyResult instanceof Promise || valueResult instanceof Promise) {\n                proms.push(Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {\n                    handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n                }));\n            }\n            else {\n                handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);\n            }\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {\n    if (keyResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, keyResult.issues));\n        }\n        else {\n            final.issues.push({\n                code: \"invalid_key\",\n                origin: \"map\",\n                input,\n                inst,\n                issues: keyResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    if (valueResult.issues.length) {\n        if (util.propertyKeyTypes.has(typeof key)) {\n            final.issues.push(...util.prefixIssues(key, valueResult.issues));\n        }\n        else {\n            final.issues.push({\n                origin: \"map\",\n                code: \"invalid_element\",\n                input,\n                inst,\n                key: key,\n                issues: valueResult.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n            });\n        }\n    }\n    final.value.set(keyResult.value, valueResult.value);\n}\nexport const $ZodSet = /*@__PURE__*/ core.$constructor(\"$ZodSet\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        const input = payload.value;\n        if (!(input instanceof Set)) {\n            payload.issues.push({\n                input,\n                inst,\n                expected: \"set\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        const proms = [];\n        payload.value = new Set();\n        for (const item of input) {\n            const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);\n            if (result instanceof Promise) {\n                proms.push(result.then((result) => handleSetResult(result, payload)));\n            }\n            else\n                handleSetResult(result, payload);\n        }\n        if (proms.length)\n            return Promise.all(proms).then(() => payload);\n        return payload;\n    };\n});\nfunction handleSetResult(result, final) {\n    if (result.issues.length) {\n        final.issues.push(...result.issues);\n    }\n    final.value.add(result.value);\n}\nexport const $ZodEnum = /*@__PURE__*/ core.$constructor(\"$ZodEnum\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const values = util.getEnumValues(def.entries);\n    const valuesSet = new Set(values);\n    inst._zod.values = valuesSet;\n    inst._zod.pattern = new RegExp(`^(${values\n        .filter((k) => util.propertyKeyTypes.has(typeof k))\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o.toString()))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (valuesSet.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodLiteral = /*@__PURE__*/ core.$constructor(\"$ZodLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    if (def.values.length === 0) {\n        throw new Error(\"Cannot create literal schema with no valid values\");\n    }\n    inst._zod.values = new Set(def.values);\n    inst._zod.pattern = new RegExp(`^(${def.values\n        .map((o) => (typeof o === \"string\" ? util.escapeRegex(o) : o ? util.escapeRegex(o.toString()) : String(o)))\n        .join(\"|\")})$`);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        if (inst._zod.values.has(input)) {\n            return payload;\n        }\n        payload.issues.push({\n            code: \"invalid_value\",\n            values: def.values,\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodFile = /*@__PURE__*/ core.$constructor(\"$ZodFile\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        const input = payload.value;\n        // @ts-ignore\n        if (input instanceof File)\n            return payload;\n        payload.issues.push({\n            expected: \"file\",\n            code: \"invalid_type\",\n            input,\n            inst,\n        });\n        return payload;\n    };\n});\nexport const $ZodTransform = /*@__PURE__*/ core.$constructor(\"$ZodTransform\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(inst.constructor.name);\n        }\n        const _out = def.transform(payload.value, payload);\n        if (ctx.async) {\n            const output = _out instanceof Promise ? _out : Promise.resolve(_out);\n            return output.then((output) => {\n                payload.value = output;\n                return payload;\n            });\n        }\n        if (_out instanceof Promise) {\n            throw new core.$ZodAsyncError();\n        }\n        payload.value = _out;\n        return payload;\n    };\n});\nfunction handleOptionalResult(result, input) {\n    if (result.issues.length && input === undefined) {\n        return { issues: [], value: undefined };\n    }\n    return result;\n}\nexport const $ZodOptional = /*@__PURE__*/ core.$constructor(\"$ZodOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    inst._zod.optout = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;\n    });\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)})?$`) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        if (def.innerType._zod.optin === \"optional\") {\n            const result = def.innerType._zod.run(payload, ctx);\n            if (result instanceof Promise)\n                return result.then((r) => handleOptionalResult(r, payload.value));\n            return handleOptionalResult(result, payload.value);\n        }\n        if (payload.value === undefined) {\n            return payload;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNullable = /*@__PURE__*/ core.$constructor(\"$ZodNullable\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"pattern\", () => {\n        const pattern = def.innerType._zod.pattern;\n        return pattern ? new RegExp(`^(${util.cleanRegex(pattern.source)}|null)$`) : undefined;\n    });\n    util.defineLazy(inst._zod, \"values\", () => {\n        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        // Forward direction (decode): allow null to pass through\n        if (payload.value === null)\n            return payload;\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodDefault = /*@__PURE__*/ core.$constructor(\"$ZodDefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // inst._zod.qin = \"true\";\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply defaults for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n            /**\n             * $ZodDefault returns the default value immediately in forward direction.\n             * It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n            return payload;\n        }\n        // Forward direction: continue with default handling\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleDefaultResult(result, def));\n        }\n        return handleDefaultResult(result, def);\n    };\n});\nfunction handleDefaultResult(payload, def) {\n    if (payload.value === undefined) {\n        payload.value = def.defaultValue;\n    }\n    return payload;\n}\nexport const $ZodPrefault = /*@__PURE__*/ core.$constructor(\"$ZodPrefault\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.optin = \"optional\";\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply prefault for undefined input\n        if (payload.value === undefined) {\n            payload.value = def.defaultValue;\n        }\n        return def.innerType._zod.run(payload, ctx);\n    };\n});\nexport const $ZodNonOptional = /*@__PURE__*/ core.$constructor(\"$ZodNonOptional\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => {\n        const v = def.innerType._zod.values;\n        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;\n    });\n    inst._zod.parse = (payload, ctx) => {\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => handleNonOptionalResult(result, inst));\n        }\n        return handleNonOptionalResult(result, inst);\n    };\n});\nfunction handleNonOptionalResult(payload, inst) {\n    if (!payload.issues.length && payload.value === undefined) {\n        payload.issues.push({\n            code: \"invalid_type\",\n            expected: \"nonoptional\",\n            input: payload.value,\n            inst,\n        });\n    }\n    return payload;\n}\nexport const $ZodSuccess = /*@__PURE__*/ core.$constructor(\"$ZodSuccess\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            throw new core.$ZodEncodeError(\"ZodSuccess\");\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.issues.length === 0;\n                return payload;\n            });\n        }\n        payload.value = result.issues.length === 0;\n        return payload;\n    };\n});\nexport const $ZodCatch = /*@__PURE__*/ core.$constructor(\"$ZodCatch\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        // Forward direction (decode): apply catch logic\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then((result) => {\n                payload.value = result.value;\n                if (result.issues.length) {\n                    payload.value = def.catchValue({\n                        ...payload,\n                        error: {\n                            issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                        },\n                        input: payload.value,\n                    });\n                    payload.issues = [];\n                }\n                return payload;\n            });\n        }\n        payload.value = result.value;\n        if (result.issues.length) {\n            payload.value = def.catchValue({\n                ...payload,\n                error: {\n                    issues: result.issues.map((iss) => util.finalizeIssue(iss, ctx, core.config())),\n                },\n                input: payload.value,\n            });\n            payload.issues = [];\n        }\n        return payload;\n    };\n});\nexport const $ZodNaN = /*@__PURE__*/ core.$constructor(\"$ZodNaN\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"number\" || !Number.isNaN(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"nan\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodPipe = /*@__PURE__*/ core.$constructor(\"$ZodPipe\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handlePipeResult(right, def.in, ctx));\n            }\n            return handlePipeResult(right, def.in, ctx);\n        }\n        const left = def.in._zod.run(payload, ctx);\n        if (left instanceof Promise) {\n            return left.then((left) => handlePipeResult(left, def.out, ctx));\n        }\n        return handlePipeResult(left, def.out, ctx);\n    };\n});\nfunction handlePipeResult(left, next, ctx) {\n    if (left.issues.length) {\n        // prevent further checks\n        left.aborted = true;\n        return left;\n    }\n    return next._zod.run({ value: left.value, issues: left.issues }, ctx);\n}\nexport const $ZodCodec = /*@__PURE__*/ core.$constructor(\"$ZodCodec\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"values\", () => def.in._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n    util.defineLazy(inst._zod, \"propValues\", () => def.in._zod.propValues);\n    inst._zod.parse = (payload, ctx) => {\n        const direction = ctx.direction || \"forward\";\n        if (direction === \"forward\") {\n            const left = def.in._zod.run(payload, ctx);\n            if (left instanceof Promise) {\n                return left.then((left) => handleCodecAResult(left, def, ctx));\n            }\n            return handleCodecAResult(left, def, ctx);\n        }\n        else {\n            const right = def.out._zod.run(payload, ctx);\n            if (right instanceof Promise) {\n                return right.then((right) => handleCodecAResult(right, def, ctx));\n            }\n            return handleCodecAResult(right, def, ctx);\n        }\n    };\n});\nfunction handleCodecAResult(result, def, ctx) {\n    if (result.issues.length) {\n        // prevent further checks\n        result.aborted = true;\n        return result;\n    }\n    const direction = ctx.direction || \"forward\";\n    if (direction === \"forward\") {\n        const transformed = def.transform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.out, ctx);\n    }\n    else {\n        const transformed = def.reverseTransform(result.value, result);\n        if (transformed instanceof Promise) {\n            return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));\n        }\n        return handleCodecTxResult(result, transformed, def.in, ctx);\n    }\n}\nfunction handleCodecTxResult(left, value, nextSchema, ctx) {\n    // Check if transform added any issues\n    if (left.issues.length) {\n        left.aborted = true;\n        return left;\n    }\n    return nextSchema._zod.run({ value, issues: left.issues }, ctx);\n}\nexport const $ZodReadonly = /*@__PURE__*/ core.$constructor(\"$ZodReadonly\", (inst, def) => {\n    $ZodType.init(inst, def);\n    util.defineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n    util.defineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n    util.defineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n    util.defineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n    inst._zod.parse = (payload, ctx) => {\n        if (ctx.direction === \"backward\") {\n            return def.innerType._zod.run(payload, ctx);\n        }\n        const result = def.innerType._zod.run(payload, ctx);\n        if (result instanceof Promise) {\n            return result.then(handleReadonlyResult);\n        }\n        return handleReadonlyResult(result);\n    };\n});\nfunction handleReadonlyResult(payload) {\n    payload.value = Object.freeze(payload.value);\n    return payload;\n}\nexport const $ZodTemplateLiteral = /*@__PURE__*/ core.$constructor(\"$ZodTemplateLiteral\", (inst, def) => {\n    $ZodType.init(inst, def);\n    const regexParts = [];\n    for (const part of def.parts) {\n        if (typeof part === \"object\" && part !== null) {\n            // is Zod schema\n            if (!part._zod.pattern) {\n                // if (!source)\n                throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);\n            }\n            const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;\n            if (!source)\n                throw new Error(`Invalid template literal part: ${part._zod.traits}`);\n            const start = source.startsWith(\"^\") ? 1 : 0;\n            const end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n            regexParts.push(source.slice(start, end));\n        }\n        else if (part === null || util.primitiveTypes.has(typeof part)) {\n            regexParts.push(util.escapeRegex(`${part}`));\n        }\n        else {\n            throw new Error(`Invalid template literal part: ${part}`);\n        }\n    }\n    inst._zod.pattern = new RegExp(`^${regexParts.join(\"\")}$`);\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"string\") {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                expected: \"template_literal\",\n                code: \"invalid_type\",\n            });\n            return payload;\n        }\n        inst._zod.pattern.lastIndex = 0;\n        if (!inst._zod.pattern.test(payload.value)) {\n            payload.issues.push({\n                input: payload.value,\n                inst,\n                code: \"invalid_format\",\n                format: def.format ?? \"template_literal\",\n                pattern: inst._zod.pattern.source,\n            });\n            return payload;\n        }\n        return payload;\n    };\n});\nexport const $ZodFunction = /*@__PURE__*/ core.$constructor(\"$ZodFunction\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._def = def;\n    inst._zod.def = def;\n    inst.implement = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implement() must be called with a function\");\n        }\n        return function (...args) {\n            const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;\n            const result = Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return parse(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst.implementAsync = (func) => {\n        if (typeof func !== \"function\") {\n            throw new Error(\"implementAsync() must be called with a function\");\n        }\n        return async function (...args) {\n            const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;\n            const result = await Reflect.apply(func, this, parsedArgs);\n            if (inst._def.output) {\n                return await parseAsync(inst._def.output, result);\n            }\n            return result;\n        };\n    };\n    inst._zod.parse = (payload, _ctx) => {\n        if (typeof payload.value !== \"function\") {\n            payload.issues.push({\n                code: \"invalid_type\",\n                expected: \"function\",\n                input: payload.value,\n                inst,\n            });\n            return payload;\n        }\n        // Check if output is a promise type to determine if we should use async implementation\n        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === \"promise\";\n        if (hasPromiseOutput) {\n            payload.value = inst.implementAsync(payload.value);\n        }\n        else {\n            payload.value = inst.implement(payload.value);\n        }\n        return payload;\n    };\n    inst.input = (...args) => {\n        const F = inst.constructor;\n        if (Array.isArray(args[0])) {\n            return new F({\n                type: \"function\",\n                input: new $ZodTuple({\n                    type: \"tuple\",\n                    items: args[0],\n                    rest: args[1],\n                }),\n                output: inst._def.output,\n            });\n        }\n        return new F({\n            type: \"function\",\n            input: args[0],\n            output: inst._def.output,\n        });\n    };\n    inst.output = (output) => {\n        const F = inst.constructor;\n        return new F({\n            type: \"function\",\n            input: inst._def.input,\n            output,\n        });\n    };\n    return inst;\n});\nexport const $ZodPromise = /*@__PURE__*/ core.$constructor(\"$ZodPromise\", (inst, def) => {\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, ctx) => {\n        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));\n    };\n});\nexport const $ZodLazy = /*@__PURE__*/ core.$constructor(\"$ZodLazy\", (inst, def) => {\n    $ZodType.init(inst, def);\n    // let _innerType!: any;\n    // util.defineLazy(def, \"getter\", () => {\n    //   if (!_innerType) {\n    //     _innerType = def.getter();\n    //   }\n    //   return () => _innerType;\n    // });\n    util.defineLazy(inst._zod, \"innerType\", () => def.getter());\n    util.defineLazy(inst._zod, \"pattern\", () => inst._zod.innerType._zod.pattern);\n    util.defineLazy(inst._zod, \"propValues\", () => inst._zod.innerType._zod.propValues);\n    util.defineLazy(inst._zod, \"optin\", () => inst._zod.innerType._zod.optin ?? undefined);\n    util.defineLazy(inst._zod, \"optout\", () => inst._zod.innerType._zod.optout ?? undefined);\n    inst._zod.parse = (payload, ctx) => {\n        const inner = inst._zod.innerType;\n        return inner._zod.run(payload, ctx);\n    };\n});\nexport const $ZodCustom = /*@__PURE__*/ core.$constructor(\"$ZodCustom\", (inst, def) => {\n    checks.$ZodCheck.init(inst, def);\n    $ZodType.init(inst, def);\n    inst._zod.parse = (payload, _) => {\n        return payload;\n    };\n    inst._zod.check = (payload) => {\n        const input = payload.value;\n        const r = def.fn(input);\n        if (r instanceof Promise) {\n            return r.then((r) => handleRefineResult(r, payload, input, inst));\n        }\n        handleRefineResult(r, payload, input, inst);\n        return;\n    };\n});\nfunction handleRefineResult(result, payload, input, inst) {\n    if (!result) {\n        const _iss = {\n            code: \"custom\",\n            input,\n            inst, // incorporates params.error into issue reporting\n            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting\n            continue: !inst._zod.def.abort,\n            // params: inst._zod.def.params,\n        };\n        if (inst._zod.def.params)\n            _iss.params = inst._zod.def.params;\n        payload.issues.push(util.issue(_iss));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}